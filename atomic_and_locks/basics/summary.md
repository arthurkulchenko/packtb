- static variables still can be used by spawnd threads even if main program exits
- println! macro use Stdout::lock
- thread could be build using thread::Builder::new
- threads could be scoped that way we can be sure than threds won't outlive certian scope
- when the scope ends, all threads that haven't joined yet are automatically joined
- static value do not belong to any thread, they are owned by program, static item has a constant initializer and is never droped and already exists before the main.
- Box::leak() is used make variable outlive the scope it get created in
- Reference Counting - Arc - smart pointer make sure that the value is not dropped until all references to it are gone - they share ownership
- It is better to shadow Arc variable name inside thread semantic scope
- Rc and Arc - *mutates* the reference count atomically which is a part of a type
- Cell<T: Copy> allow mutation through a shared reference. it only allow to copy value out(if T is Copy) or swap whole value out works only in single thread
- RefCell<T> - holds T but also holds a counter. can't be mutable borrowed if already borrowed immutably. works only in single thread.
- RwLock is concurrent version of a RefCell instead of panicing when another pointer wants to mutate the value, it will block(puts in a sleep) the thread until the lock is released.
- Mutex instead of tracking the number of shared and exclusive references, allows only exclusive.
- Atomics type represents the concurrent version of a Cell.
- UnsafeCell has get() method which returns a raw pointer
- Send type can be sent to another thread - ownership is transfered
- Sync type can be shared with another thread. All primitives types are Send and Sync.
- PhantomData<T> can serve as an constrain to a type making it Send with a T that is not Sync.
- Lock Poisoning - when a Mutex is pamics while locked/
- Parking thread::park will put thread to sleep until it is woken up by t.thread().unpark() where t parked thread.
- Condvar use wait(lock) method to put thread to sleep and notify_one() or notify_all() to wake up the thread.
